.\" File automatically generated by doxy2man0.1
.\" Generation date: mar. avr. 24 2018
.TH rohc_comp_get_segment2 3 2018-04-24 "ROHC" "ROHC library Programmer's Manual"
.SH "NAME"
rohc_comp_get_segment2 \- Get the next ROHC segment if any.
.SH SYNOPSIS
.nf
.B #include <rohc/rohc_comp.h>
.sp
\fBrohc_status_t rohc_comp_get_segment2\fP(
    \fBstruct rohc_comp *const  comp\fP,
    \fBstruct rohc_buf *const   segment\fP
);
.fi
.SH DESCRIPTION
.PP 
Get the next ROHC segment if any.
.PP 
To get all the segments of one ROHC packet, call this function until \fBROHC_STATUS_OK\fP or \fBROHC_STATUS_ERROR\fP is returned.
.SH PARAMETERS
.TP
.B comp
The ROHC compressor 
.TP
.B segment [output]
The buffer where to store the ROHC segment 
.SH STRUCTURES
.SS "A network buffer for the ROHC library"
.PP
.sp
.PP 
May represent one uncompressed packet, one ROHC packet, or a ROHC feedback.
.PP 
The network buffer does not contain the packet data itself. It only has a pointer on it. This is designed this way for performance reasons: no copy required to initialize a network buffer, the struct is small and may be passed as copy to function.
.PP 
The network buffer is able to keep some free space at its beginning. The unused space at the beginning of the buffer may be used to prepend a network header at the very end of the packet handling.
.PP 
The beginning of the network buffer may also be shifted forward with the \fBrohc_buf_pull\fP function or shifted backward with the \fBrohc_buf_push\fP function. This is useful when parsing a network packet (once bytes are read, shift them forward) for example.
.PP 
The network buffer may be initialized manually (see below) or with the helper functions \fBrohc_buf_init_empty\fP or \fBrohc_buf_init_full\fP...
.PP 
 
.sp
.RS
.nf
struct \fBrohc_buf\fP {
  struct rohc_ts \fItime\fP;    /* The timestamp associated to the data */
  uint8_t       *\fIdata\fP;    /* The buffer data */
  size_t         \fImax_len\fP; /* The maximum length of the buffer */
  size_t         \fIoffset\fP;  /* The offset for the beginning of the data */
  size_t         \fIlen\fP;     /* The data length (in bytes) */
};
.fi
.RE
.SH RETURN VALUE
.PP
Possible return values: 
.RS

\(bu \fBROHC_STATUS_SEGMENT\fP if a ROHC segment is returned and more segments are available, 

\(bu \fBROHC_STATUS_OK\fP if a ROHC segment is returned and no more ROHC segment is available 

\(bu \fBROHC_STATUS_ERROR\fP if an error occurred


.RE


.SH EXAMPLE
.nf
struct rohc_comp *comp;

ess the IP packet with a small ROHC buffer
status = rohc_compress4(comp, ip_packet, &rohc_packet);
if(status == ROHC_STATUS_SEGMENT)
{
        /* ROHC segmentation is required to compress the IP packet */
        /* get the segments */
        while((status = rohc_comp_get_segment2(comp, &rohc_packet)) == ROHC_STATUS_SEGMENT)
        {
                /* new ROHC segment retrieved */

press the ROHC segment here, the function
decompress3 shall return ROHC_STATUS_OK
o decompressed packet

                if(uncomp_packet.len > 0)
                {
                        fprintf(stderr, "\tdecompression of ROHC segment succeeded while "
                                "it should have not\n");
                        goto destroy_decomp;
                }
                rohc_packet.len = 0;
        }
        if(status != ROHC_STATUS_OK)
        {
                fprintf(stderr, "failed to generate ROHC segment (status = %d)\n",
                        status);
                goto destroy_decomp;
        }
        /* final ROHC segment retrieved */
press the final ROHC segment here, the function
decompress4 shall return ROHC_STATUS_OK
        if(uncomp_packet.len == 0)
        {
                fprintf(stderr, "\tdecompression of ROHC segment failed while it "
                        "should have succeeded\n");
                goto destroy_decomp;
        }
}
else if(status != ROHC_STATUS_OK)
{
e compression error here




.fi
.SH SEE ALSO
.BR rohc_comp.h (3),
.BR ROHC_STATUS_OK (3),
.BR ROHC_STATUS_ERROR (3),
.BR ROHC_STATUS_SEGMENT (3),
.BR rohc_comp_get_mrru (3),
.BR rohc_comp_set_mrru (3),
.BR rohc_compress4 (3)
